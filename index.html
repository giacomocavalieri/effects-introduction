<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.101.0"><meta charset=utf-8><title>Effects</title><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=/effects-introduction/reveal-js/css/reset.css><link rel=stylesheet href=/effects-introduction/reveal-js/css/reveal.css><link rel=stylesheet href=/effects-introduction/custom.css id=theme><link rel=stylesheet href=/effects-introduction/highlight-js/default.min.css></head><body><div class=reveal><div class=slides><section><h2 id=effects>Effects</h2><p>The essence of programming ultimately boils down to performing effects. As Simon Peyton Jones puts it:</p><blockquote><p>If a program has no side-effects there&rsquo;s no point in running it, isn&rsquo;t it? You have a black box, you press go and it gets hot but there&rsquo;s no output <sup><a href=#cited-sources>^1</a></sup></p></blockquote></section><section><h2 id=a-simple-running-example>A simple running example</h2><p>Being undoubtedly very convenient, many languages allow the programmer to use <em>statements</em> as a way to perform unrestricted side-effects: I/O, failure, non-determinism, &mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=k>def</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>println</span><span class=o>(</span><span class=s>&#34;Flipping a coin&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>heads</span> <span class=k>=</span> <span class=n>util</span><span class=o>.</span><span class=nc>Random</span><span class=o>.</span><span class=n>nextBoolean</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>heads</span> <span class=n>then</span> <span class=n>n</span><span class=o>*</span><span class=mi>2</span> <span class=k>else</span> <span class=n>n</span>
</span></span></code></pre></div></section><section><p>The problem with unrestricted side effects is that there is no <em>referential transparency:</em>
while one can factor out duplicate values the same is not true for statements,
they are not easily testable and it is overall harder to reason about the program&rsquo;s behavior</p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=k>val</span> <span class=n>program1</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=mi>1</span><span class=o>)</span> <span class=o>+</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>program2</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=o>{</span>Â <span class=k>val</span> <span class=n>n</span> <span class=k>=</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span> <span class=n>n</span> <span class=o>+</span> <span class=n>n</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>// the two programs are not equivalent since maybeDouble
</span></span></span><span class=line><span class=cl><span class=c1>// performs side effects
</span></span></span></code></pre></div></section><section><h2 id=monads-to-the-rescue>Monads to the rescue</h2><p>In a purely functional world the key difference is that a program no longer performs the side effects but it is an immutable data structure that <em>describes</em> what side effects need to be performed:</p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=k>def</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>Int</span><span class=o>]</span> <span class=k>=</span> <span class=k>for</span>
</span></span><span class=line><span class=cl>  <span class=k>_</span>     <span class=k>&lt;-</span> <span class=nc>IO</span><span class=o>.</span><span class=n>println</span><span class=o>(</span><span class=s>&#34;Flipping a coin&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=n>heads</span> <span class=k>&lt;-</span> <span class=nc>IO</span><span class=o>(</span><span class=n>util</span><span class=o>.</span><span class=nc>Random</span><span class=o>.</span><span class=n>nextBoolean</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>yield</span> <span class=o>(</span><span class=k>if</span> <span class=n>heads</span> <span class=n>then</span> <span class=n>n</span><span class=o>*</span><span class=mi>2</span> <span class=k>else</span> <span class=n>n</span><span class=o>)</span>
</span></span></code></pre></div></section><section><p>Thanks to the <code>IO</code> monad one can treat <em>programs as first-class values:</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=k>val</span> <span class=n>p</span> <span class=k>=</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>ns</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>List</span><span class=o>[</span><span class=kt>Int</span><span class=o>]]</span> <span class=k>=</span> <span class=nc>List</span><span class=o>.</span><span class=n>fill</span><span class=o>(</span><span class=mi>5</span><span class=o>)(</span><span class=n>p</span><span class=o>).</span><span class=n>sequence</span>
</span></span></code></pre></div><p><code>p</code> is not an integer value that could be either 10 or 20; it is an immutable data structure that describes the logic with which 10 may or may not be doubled by performing side-effects</p></section><section><h2 id=the-problem-with-io>The problem with IO</h2><p>Simply using <code>IO</code> does not magically solve our problems:</p><ul><li>the code inside <code>IO</code> is just as hard to test as the impure counterpart</li><li>inside <code>IO</code> I could perform <em>all kinds</em> of I/O (read a file, send messages over<br>the network, fail with an exception, &mldr;)</li><li>having the <code>IO</code> monad everywhere is like not having it at all!</li></ul></section><section><h2 id=goals-of-an-effect-system>Goals of an effect system</h2><p>We wish to express the side effects our code can perform so that:</p><ul><li>the code can be <em>easily composed and tested</em></li><li>the correct handling of side effects is <em>checked at compile-time</em></li><li>the side effects can be expressed with a <em>granularity suitable for our business needs</em></li></ul></section><section><p>Each effect system can be evaluated in terms of:</p><ul><li>cognitive load</li><li>ease of use</li><li>composability</li><li>testability</li><li>performance</li><li>maturity</li><li>&mldr;</li></ul></section><section><h2 id=monad-stacks>Monad Stacks</h2><p>Thanks to <em>monad transformers,</em> monads can be <em>stacked</em> together to obtain composite monads
that provide multiple side effects</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=c1>// Enrich M[_] with the effects of the Maybe monad (failure)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>final</span> <span class=k>case</span> <span class=k>class</span> <span class=nc>MaybeT</span><span class=o>[</span><span class=kt>M</span><span class=o>[</span><span class=k>_</span><span class=o>]</span>, <span class=kt>A</span><span class=o>](</span><span class=n>runMaybeT</span> <span class=k>:</span> <span class=kt>M</span><span class=o>[</span><span class=kt>Maybe</span><span class=o>[</span><span class=kt>A</span><span class=o>]])</span>
</span></span><span class=line><span class=cl><span class=c1>// Enrich M[_] with the effects of the State monad (global mutable state)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>final</span> <span class=k>case</span> <span class=k>class</span> <span class=nc>StateT</span><span class=o>[</span><span class=kt>S</span>, <span class=kt>M</span><span class=o>[</span><span class=k>_</span><span class=o>]</span>, <span class=kt>A</span><span class=o>](</span><span class=n>runStateT</span> <span class=k>:</span> <span class=kt>S</span> <span class=o>=&gt;</span> <span class=n>M</span><span class=o>[(</span><span class=kt>A</span>, <span class=kt>S</span><span class=o>)])</span>
</span></span><span class=line><span class=cl><span class=c1>// Enrich M[_] with the effects of the Reader monad (global read-only state) 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>final</span> <span class=k>case</span> <span class=k>class</span> <span class=nc>ReaderT</span><span class=o>[</span><span class=kt>S</span>, <span class=kt>M</span><span class=o>[</span><span class=k>_</span><span class=o>]</span>, <span class=kt>A</span><span class=o>](</span><span class=n>runReaderT</span> <span class=k>:</span> <span class=kt>S</span> <span class=o>=&gt;</span> <span class=n>M</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span>
</span></span></code></pre></div></p></section><section><p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=c1>// With the compiler plugin -Ykind-projector:underscores enabled
</span></span></span><span class=line><span class=cl><span class=c1>// one can define a type lambda with the same syntax used for 
</span></span></span><span class=line><span class=cl><span class=c1>// a term lambda
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>def</span> <span class=n>program</span><span class=k>:</span> <span class=kt>MaybeT</span><span class=o>[</span><span class=kt>ReaderT</span><span class=o>[</span><span class=kt>String</span>, <span class=kt>IO</span>, <span class=k>_</span><span class=o>]</span>, <span class=kt>Int</span><span class=o>]</span> <span class=k>=</span> <span class=o>...</span>
</span></span></code></pre></div></p><p>Using a monad stack allows expressing a program that can perform 3 kinds of side effects:
failure (<code>MaybeT</code>), reading a global immutable configuration (<code>ReaderT</code>) and performing I/O (<code>IO</code>)</p><p>However, programming against a particular monad stack forces one to use a specific implementation
<em>breaking encapsulation</em> <sup><a href=#cited-sources>^2</a></sup></p></section><section><h2 id=mtl--tagless-final-sup3cited-sourcessup>MTL / Tagless Final <sup><a href=#cited-sources>^3</a></sup></h2><p>The effects/capabilities are encoded with type classes that can be
used as constraints to express the effects available in a given context</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=k>trait</span> <span class=nc>CoinFlip</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=o>{</span> <span class=k>def</span> <span class=n>flipCoin</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Boolean</span><span class=o>]</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>trait</span> <span class=nc>Console</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span>  <span class=o>{</span> <span class=k>def</span> <span class=n>printLine</span><span class=o>(</span><span class=n>s</span><span class=k>:</span> <span class=kt>String</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Unit</span><span class=o>]</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Plus some more boilerplate...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>def</span> <span class=n>maybeDouble</span><span class=o>[</span><span class=kt>M</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Monad:</span> <span class=kt>CoinFlip:</span> <span class=kt>Console</span><span class=o>](</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>M</span><span class=o>[</span><span class=kt>Int</span><span class=o>]</span> <span class=k>=</span> <span class=k>for</span> 
</span></span><span class=line><span class=cl>  <span class=k>_</span>     <span class=k>&lt;-</span> <span class=nc>Console</span><span class=o>[</span><span class=kt>M</span><span class=o>].</span><span class=n>printLine</span><span class=o>(</span><span class=s>&#34;Flipping a coin&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=n>heads</span> <span class=k>&lt;-</span> <span class=nc>CoinFlip</span><span class=o>[</span><span class=kt>M</span><span class=o>].</span><span class=n>flipCoin</span>
</span></span><span class=line><span class=cl><span class=k>yield</span> <span class=o>(</span><span class=k>if</span> <span class=n>heads</span> <span class=n>then</span> <span class=n>n</span><span class=o>*</span><span class=mi>2</span> <span class=k>else</span> <span class=n>n</span><span class=o>)</span>
</span></span></code></pre></div></p></section><section><h2 id=interpreting-the-mtl-program>Interpreting the MTL program</h2><p>Interpreting the program consists in choosing an appropriate monad
(inside which all effects can be carried out) and implementing
the instances of the needed type classes</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=n>given</span> <span class=nc>CoinFlip</span><span class=o>[</span><span class=kt>IO</span><span class=o>]</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>flipCoin</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>Boolean</span><span class=o>]</span> <span class=k>=</span> <span class=nc>IO</span><span class=o>(</span><span class=n>util</span><span class=o>.</span><span class=nc>Random</span><span class=o>.</span><span class=n>nextBoolean</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>given</span> <span class=nc>Console</span><span class=o>[</span><span class=kt>IO</span><span class=o>]</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>printLine</span><span class=o>(</span><span class=n>s</span><span class=k>:</span> <span class=kt>String</span><span class=o>)</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>Unit</span><span class=o>]</span> <span class=k>=</span> <span class=nc>IO</span><span class=o>.</span><span class=n>println</span><span class=o>(</span><span class=n>s</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>main</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>Unit</span><span class=o>]</span> <span class=k>=</span> <span class=k>for</span>
</span></span><span class=line><span class=cl>  <span class=n>res</span> <span class=k>&lt;-</span> <span class=n>maybeDouble</span><span class=o>[</span><span class=kt>IO</span><span class=o>](</span><span class=mi>10</span><span class=o>)</span> <span class=c1>// maybeDouble is interpreted as the IO monad
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>_</span>   <span class=k>&lt;-</span> <span class=nc>IO</span><span class=o>.</span><span class=n>println</span><span class=o>(</span><span class=s>s&#34;The result is </span><span class=si>$res</span><span class=s>&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>yield</span> <span class=o>()</span>
</span></span></code></pre></div></p></section><section><h2 id=free-monads>Free monads</h2><p>The Free Monad pattern can also be quite useful to model the core domain logic
<em>decoupling the code description from its interpretation<sup><a href=#cited-sources>^4</a></sup></em></p><p>Despite needing a bit more boilerplate code, the program description is
essentially the same as the MTL&rsquo;s one</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=n>enum</span> <span class=nc>CoinFlipDSL</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=o>{</span> <span class=k>case</span> <span class=nc>FlipCoin</span>               <span class=k>extends</span> <span class=nc>CoinFlipDSL</span><span class=o>[</span><span class=kt>Boolean</span><span class=o>]</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=n>enum</span> <span class=nc>ConsoleDSL</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span>  <span class=o>{</span> <span class=k>case</span> <span class=nc>PrintLine</span><span class=o>(</span><span class=n>msg</span><span class=k>:</span> <span class=kt>String</span><span class=o>)</span> <span class=k>extends</span> <span class=nc>ConsoleDSL</span><span class=o>[</span><span class=kt>Unit</span><span class=o>]</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=n>enum</span> <span class=nc>AppDSL</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nc>EvalCoinFlip</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>c</span><span class=k>:</span> <span class=kt>CoinFlip</span><span class=o>[</span><span class=kt>B</span><span class=o>])</span> <span class=k>extends</span> <span class=nc>AppDSL</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span> <span class=c1>// GADT
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>case</span> <span class=nc>EvalConsole</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>c</span><span class=k>:</span> <span class=kt>Console</span><span class=o>[</span><span class=kt>B</span><span class=o>])</span>   <span class=k>extends</span> <span class=nc>AppDSL</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Plus some more boilerplate...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>def</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>App</span><span class=o>[</span><span class=kt>Int</span><span class=o>]</span> <span class=k>=</span> <span class=k>for</span>
</span></span><span class=line><span class=cl>  <span class=k>_</span>     <span class=k>&lt;-</span> <span class=nc>App</span><span class=o>.</span><span class=n>printLine</span><span class=o>(</span><span class=s>&#34;Flipping a coin!&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=n>heads</span> <span class=k>&lt;-</span> <span class=nc>App</span><span class=o>.</span><span class=n>flipCoin</span>
</span></span><span class=line><span class=cl><span class=k>yield</span> <span class=o>(</span><span class=k>if</span> <span class=n>heads</span> <span class=n>then</span> <span class=n>n</span> <span class=o>*</span> <span class=mi>2</span> <span class=k>else</span> <span class=n>n</span><span class=o>)</span>
</span></span></code></pre></div></p></section><section><h2 id=interpreting-the-free-monad>Interpreting the Free monad</h2><p>Interpreting the program consists in providing a natural transformation
from the DSL to another language. There could be many interpreters, each one
<em>compiling the DSL to a lower-level instruction set</em> that can then be interpreted
inside the <code>IO</code> monad</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=k>val</span> <span class=n>productionInterpreter</span> <span class=k>=</span> <span class=k>new</span> <span class=o>(</span><span class=nc>AppDSL</span> <span class=o>~&gt;</span> <span class=nc>IO</span><span class=o>)</span><span class=k>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>override</span> <span class=kt>def</span> <span class=kt>apply</span><span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>a</span><span class=k>:</span> <span class=kt>AppDSL</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=k>=</span> <span class=n>a</span> <span class=k>match</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nc>EvalCoinFlip</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>c</span><span class=o>.</span><span class=n>runWith</span><span class=o>(</span><span class=n>productionCoinFlipInterpreter</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nc>EvalConsole</span><span class=o>(</span><span class=n>c</span><span class=o>)</span>  <span class=k>=&gt;</span> <span class=n>c</span><span class=o>.</span><span class=n>runWith</span><span class=o>(</span><span class=n>productionConsoleInterpreter</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>productionCoinFlipInterpreter</span> <span class=k>=</span> <span class=k>new</span> <span class=o>(</span><span class=nc>CoinFlipDSL</span> <span class=o>~&gt;</span> <span class=nc>IO</span><span class=o>)</span><span class=k>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>override</span> <span class=kt>def</span> <span class=kt>apply</span><span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>cf</span><span class=k>:</span> <span class=kt>CoinFlipDSL</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=k>=</span> <span class=n>cf</span> <span class=k>match</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nc>FlipCoin</span> <span class=k>=&gt;</span> <span class=nc>IO</span><span class=o>(</span><span class=n>util</span><span class=o>.</span><span class=nc>Random</span><span class=o>.</span><span class=n>nextBoolean</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>productionConsoleInterpreter</span> <span class=k>=</span> <span class=k>new</span> <span class=o>(</span><span class=nc>ConsoleDSL</span> <span class=o>~&gt;</span> <span class=nc>IO</span><span class=o>)</span><span class=k>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>override</span> <span class=kt>def</span> <span class=kt>apply</span><span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>c</span><span class=k>:</span> <span class=kt>ConsoleDSL</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=k>=</span> <span class=n>c</span> <span class=k>match</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nc>PrintLine</span><span class=o>(</span><span class=n>msg</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=nc>IO</span><span class=o>.</span><span class=n>println</span><span class=o>(</span><span class=n>msg</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>main</span> <span class=k>=</span> <span class=k>for</span>
</span></span><span class=line><span class=cl>  <span class=n>res</span> <span class=k>&lt;-</span> <span class=n>maybeDouble</span><span class=o>(</span><span class=mi>10</span><span class=o>).</span><span class=n>runWith</span><span class=o>(</span><span class=n>productionInterpreter</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>_</span>   <span class=k>&lt;-</span> <span class=nc>IO</span><span class=o>.</span><span class=n>println</span><span class=o>(</span><span class=s>s&#34;The result is: </span><span class=si>$res</span><span class=s>&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>yield</span> <span class=o>()</span>
</span></span></code></pre></div></p></section><section><h2 id=ad-hoc-languages-unison>Ad hoc languages: Unison</h2><p>Some languages give native support to algebraic effects: that is
functions are polymorphic on the effects they may produce and the type checker
verifies that there are no unhandled effects.</p><p>All the following examples are written in <a href=https://www.unison-lang.org>Unison</a>: a statically-typed, functional language which uses <em>abilities</em> as a way to manage
effects</p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=nf>structural</span> <span class=n>ability</span> <span class=kt>CoinFlip</span> <span class=kr>where</span> <span class=n>flipCoin</span> <span class=kt>:</span> <span class=kt>Boolean</span>
</span></span><span class=line><span class=cl><span class=nf>structural</span> <span class=n>ability</span> <span class=kt>Console</span>  <span class=kr>where</span> <span class=n>printLine</span> <span class=kt>:</span> <span class=kt>Text</span> <span class=ow>-&gt;</span> <span class=nb>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>-- A function specifies in {} the abilities it needs, this function</span>
</span></span><span class=line><span class=cl><span class=c1>-- requires the CoinFlip and Console abilities</span>
</span></span><span class=line><span class=cl><span class=nf>maybeDouble</span> <span class=kt>:</span> <span class=kt>Nat</span> <span class=ow>-&gt;</span>  <span class=p>{</span><span class=kt>CoinFlip</span><span class=p>,</span> <span class=kt>Console</span><span class=p>}</span> <span class=kt>Nat</span>
</span></span><span class=line><span class=cl><span class=nf>maybeDouble</span> <span class=n>n</span> <span class=ow>=</span>
</span></span><span class=line><span class=cl>  <span class=n>printLine</span> <span class=s>&#34;Flipping a coin!&#34;</span>
</span></span><span class=line><span class=cl>  <span class=n>heads</span> <span class=ow>=</span> <span class=n>flipCoin</span>
</span></span><span class=line><span class=cl>  <span class=kr>if</span> <span class=n>heads</span> <span class=kr>then</span> <span class=n>n</span><span class=o>*</span><span class=mi>2</span> <span class=kr>else</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>  <span class=c1>-- One can use a direct style, no monadic binding:</span>
</span></span><span class=line><span class=cl>  <span class=c1>-- if flipCoin then n*2 else n</span>
</span></span></code></pre></div></section><section><h2 id=interpreting-a-function-with-abilities>Interpreting a function with abilities</h2><p>The type system makes sure that no ability is unhandled and the main entry point of
the application can only access the <code>IO</code> and <code>Exception</code> abilities.
Unison provides <em>handlers</em> that can remove or replace ability requirements in the
functions&rsquo; signature by interpreting them</p><div class=highlight><pre tabindex=0 class=chroma><code class=nohighlight data-noescape><span class=line><span class=cl><span class=nf>runProductionApp</span> <span class=kt>:</span> <span class=p>(</span><span class=nb>()</span> <span class=ow>-&gt;</span> <span class=p>{</span><span class=kt>Console</span><span class=p>,</span> <span class=kt>CoinFlip</span><span class=p>}</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span><span class=p>{</span><span class=kt>IO</span><span class=p>,</span> <span class=kt>Exception</span><span class=p>}</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>runProductionApp</span> <span class=n>comp</span> <span class=ow>=</span> <span class=n>comp</span> <span class=o>|&gt;</span> <span class=n>runConsoleIO</span> <span class=o>|&gt;</span> <span class=n>runCoinFlipRandom</span> <span class=o>|&gt;</span> <span class=n>lcg</span> <span class=mi>11</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>runConsoleIO</span> <span class=kt>:</span> <span class=p>(</span><span class=nb>()</span> <span class=ow>-&gt;</span> <span class=p>{</span><span class=n>e</span><span class=p>,</span> <span class=kt>Console</span><span class=p>}</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=nb>()</span> <span class=ow>-&gt;</span> <span class=p>{</span><span class=n>e</span><span class=p>,</span> <span class=kt>IO</span><span class=p>,</span> <span class=kt>Exception</span><span class=p>}</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>runConsoleIO</span> <span class=n>comp</span> <span class=kr>_</span> <span class=ow>=</span>
</span></span><span class=line><span class=cl>  <span class=n>handler</span> <span class=ow>=</span> <span class=n>cases</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>printLine</span> <span class=n>msg</span> <span class=ow>-&gt;</span> <span class=n>k</span><span class=p>}</span> <span class=ow>-&gt;</span>  <span class=c1>-- handle a printLine request</span>
</span></span><span class=line><span class=cl>      <span class=n>console</span><span class=o>.</span><span class=n>printLine</span> <span class=n>msg</span>  <span class=c1>-- print the message using the IO ability </span>
</span></span><span class=line><span class=cl>      <span class=n>handle</span> <span class=o>!</span><span class=n>k</span> <span class=n>with</span> <span class=n>handler</span> <span class=c1>-- handle the continuation as well</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>r</span> <span class=p>}</span>                <span class=ow>-&gt;</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=n>handle</span> <span class=o>!</span><span class=n>comp</span> <span class=n>with</span> <span class=n>handler</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>runCoinFlipRandom</span> <span class=kt>:</span> <span class=p>(</span><span class=nb>()</span> <span class=ow>-&gt;</span> <span class=p>{</span><span class=n>e</span><span class=p>,</span> <span class=kt>CoinFlip</span><span class=p>}</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=nb>()</span> <span class=ow>-&gt;</span> <span class=p>{</span><span class=n>e</span><span class=p>,</span> <span class=kt>Random</span><span class=p>}</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>runCoinFlipRandom</span> <span class=n>comp</span> <span class=kr>_</span> <span class=ow>=</span>
</span></span><span class=line><span class=cl>  <span class=n>handler</span> <span class=ow>=</span> <span class=n>cases</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>flipCoin</span> <span class=ow>-&gt;</span> <span class=n>k</span><span class=p>}</span> <span class=ow>-&gt;</span> <span class=n>handle</span> <span class=n>k</span> <span class=o>!</span><span class=kt>Random</span><span class=o>.</span><span class=n>boolean</span> <span class=n>with</span> <span class=n>handler</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>r</span> <span class=p>}</span>           <span class=ow>-&gt;</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=n>handle</span> <span class=o>!</span><span class=n>comp</span> <span class=n>with</span> <span class=n>handler</span>
</span></span></code></pre></div></section><section><h2 id=cited-sources>Cited Sources</h2><ol><li><a href="https://www.youtube.com/watch?v=iSmkqocn0oQ">Simon P. Jones - Haskell is Useless</a></li><li><a href=http://dx.doi.org/10.1145/2500365.2500590>Kammar, Lindley and Oury - Handlers in Action</a></li><li><a href=http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf>Mark P. Jones - Functional Programming with Overloading and Higher-Order Polymorphism</a></li><li><a href=https://www.manning.com/books/functional-design-and-architecture>Alexander Granin - Functional Design and Architecture</a></li></ol></section></div></div><script type=text/javascript src=/effects-introduction/reveal-hugo/object-assign.js></script>
<a href=/effects-introduction/reveal-js/css/print/ id=print-location style=display:none></a>
<script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>{"custom_theme":"custom.css","slide_number":true}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=/effects-introduction/reveal-js/js/reveal.js></script>
<script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=/effects-introduction/reveal-js/plugin/markdown/marked.js></script>
<script type=text/javascript src=/effects-introduction/reveal-js/plugin/markdown/markdown.js></script>
<script type=text/javascript src=/effects-introduction/reveal-js/plugin/highlight/highlight.js></script>
<script type=text/javascript src=/effects-introduction/reveal-js/plugin/zoom-js/zoom.js></script>
<script type=text/javascript src=/effects-introduction/reveal-js/plugin/notes/notes.js></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!1});let render=e=>{let t=e.currentSlide.querySelectorAll(".mermaid");if(!t.length)return;t.forEach(e=>{let t=e.getAttribute("data-processed");t||mermaid.init(void 0,e)})};Reveal.addEventListener("slidechanged",render),Reveal.addEventListener("ready",render)</script></body></html>